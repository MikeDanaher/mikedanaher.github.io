---
layout: post
title:  "SOLID Writing Principles"
date:   2014-03-07
---

Often times, when I learn something new I immediately see it everywhere. If you've ever considered purchasing a new car, you'll know the feeling. Suddenly, everyone seems to be driving the car you want. When I started my journey towards software craftsmanship, the first topic I covered was the SOLID principles. These principles should guide every piece of code one writes and help one make decisions about design. And I'm seeing them in other things I do. One such instance is in my writing.

While the SOLID principles provide excellent guidelines for writing software, I wonder if they might also apply to writing prose. Could software developers, who understand the SOLID principles, learn to write better using them? Here's how I might use them to guide an aspiring writer.

### Single Responsibility Principle

In software development, the Single Responsibility Principle states that a class should have only one responsibility. When you're writing new classes, the moment you notice yourself writing unrelated methods, you should step back and create a new class. The same goes for writing prose. A written work should have a single purpose. And within that, each paragraph should have a single purpose. The moment you notice yourself going off on a tangent, you should step back and refocus. With modern word processors, it's extremely easy to delete whole paragraphs at a time.

By writing with a single purpose, it's easier to be clear and concise. As you brainstorm your topic, think about the various points you'll need to prove. If those points don't directly pertain to your topic, omit them. If you don't think you have enough points, hold the topic until you do. It's better to write less, than to add in unrelated filler. 

Just as in software, writing clear and simple prose takes practice. It's definitely harder to write clean, easy to follow sentences than to write complicated run-on sentences. But if you keep your focus on the purpose, it becomes much easier to cut out all the fluff. A good way to keep that focus is to look at the first sentence of each paragraph. Typically the first sentence sets up the idea and the following ones reinforce it. As you get more comfortable, you'll learn to catch yourself changing topics before you finish the paragraph.

### Open/Closed Principle

The open/closed principle states that software entities should be open for extension, but closed to modification. Put simply, you (and others) should be able to add to your entities without changing their behavior throughout the rest of the code.  Within your writing, each paragraph should add to the topic without changing what you've already written. You never want to get to the bottom of your article and find that you've talked yourself into a corner you can't get out of. If you start the paper believing one thing, but end the paper believing another, it's not going to be too convincing to your readers. Plan out your points ahead of time and stick to your story.
Within the global context, your article is your work. Others can't modify what you've written, but should be able to add to it. If you've written a successful paper, the reader should be thinking critically about the topic you've chosen. You want to evoke emotion in your readers (either pro or con) where they are driven to add to your work. You want your writing to advance the conversation, bringing up new questions and sparking new interest. Even if you're just writing for yourself, your work should motivate you to act. An extendable story is much more interesting than one that finishes with a dead end.

### Liskov Substitution Principle

Using this principle, a software developer should create classes with subclasses that are perfectly interchangeable. A subclass should override the parent's methods such that any client that can use the parent class should be able to use the subclass as well. While our writing typically doesn't involve classes and subclasses, one effective interchangeable tool is the use of a metaphor. By incorporating a metaphor into your writing, you can more easily explain complex topics using something the reader should already understand.

Just like subclasses extend their parent, metaphors extend your topic. They make their properties available to your ideas. You can use those properties to make a point, explain a concept, or connect with the reader. Metaphors make powerful tools, but can also be dangerous.

Just as with parents and their subclasses, metaphors should only be used when they are interchangeable with the topic. A metaphor that only partly matches the topic could do more harm than good. You don't want to put unnecessary ideas into the reader's head if they do not advance your purpose. Use metaphors to enhance your writing, but don't rely on them to solve every problem or explain every situation.

### Interface Segregation Principle

You should write software that is easy to interact with. Your API should make sense to the client that is using it. Many client-specific interfaces are preferred to one general-purpose interface. In this same regard, your writing (the interface) needs to consider the reader (client) consuming it.

The reader is your audience. By knowing your audience, you can create an article that gives them all the information they need. Nothing more. Nothing less. Your arguments should appeal to them. It's ok to assume a specific level of knowledge. The reader will determine if they are capable of consuming your work. If the audience or medium (i.e.presentation) should ever change, it shouldn't be that difficult to modify your arguments.

### Dependency Inversion Principle

Abstractions should not depend on details. Details should depend on abstractions. In our software, we should abstract away the dependencies as much as possible to keep our code flexible and maintainable. We should invert our dependencies such that if a method requires other code, that other code should be passed into the method. In a similar manner, if our writing depends on someone else's writing, we should pass it in and cite it properly. 

An extremely effective way to boost your own work is to reuse the work of others. This goes back to the idea of being open to extension and moving the conversation forward. By using an expert's work, you can more easily prove your own points and strengthen your own arguments. There's nothing wrong with injecting someone else's ideas as long as credit is properly given. 

When you start writing by considering the work of others, you open yourself up to a greater learning experience. Everything you read becomes possible information to use in your next work. You become more aware of your own beliefs and opinions. You start to write about topics never available to you because you never had the knowledge to explore them. By inverting the traditional dependency you have on knowledge, you can improve your writing far beyond what was possible before.

By applying the SOLID design principles to our writing, we can improve our prose and expand our influence in the community. The single responsibility principle tells us to write with focus. The open/closed principle helps us improve our reach and focus on the external effects of our work. The Liskov substitution principle pushes us to experiment with metaphors while the interface segregation principle tells us to never forget our audience. The dependency inversion principle helps us improve our work through the work of others. The skills we learn and practice as software developers are useful in many areas of our lives. Where else might those skills apply?
