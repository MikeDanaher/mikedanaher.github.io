---
layout: post
title:  "Pair Programming"
date:   2014-08-11
---

When I started as a resident apprentice at 8th Light, I quickly learned one of the main tenets of software craftsmanship: pair programming. Pairing is the practice of writing software with one computer, two keyboards, and two minds working together. It requires communication, collaboration, patience, and presence. You cannot help but be productive when pair programming.

In the first six weeks of my apprenticeship, I was fortunate to pair with a team building a rather large JavaScript application. I knew a bit about JavaScript before starting, but had never seen CoffeeScript, Backbone, Git, or anything at such a scale. In just a few short weeks of pairing, however, I feel I was comfortable with the code base, confident enough to make edits, and sufficiently familiar with the problem to make recommendations (or at least not get lost during standups and planning meetings).

A few months after that experience, I joined a new project in a completely new language and framework (Ruby and Rails). Again, I started pairing with another team member. Within a week, I was familier enough to be productive and felt that I knew my way around the project fairly well. Furthermore, I feel that my own workflow improved, I learned tips, tricks, and keyboard shortcuts, and become better friends with members of the team. Pair programming has been one of the best ways to ramp up on a new project.

But pairing is not just for adding a new member to the team. An already established team can use pairing to distribute knowledge, solve tougher problems, and create better quality code in less time. From my perspective, pair programming has been nothing but positive. But is that always the case?

Pair programming has been around in some form or another for quite some time. However, it wasn’t fully formalized until the late 1990’s when [Extreme Programming Explained](http://en.wikipedia.org/wiki/Extreme_programming) was published by Kent Beck after his work at Chrysler. Of all the Agile processes and recommendations, pairing seems to generate the most controversy.

A quick Google search of pair programming will yield millions of results. Many of them are articles with a ‘vs’ or '?' in the title. It seems everyone is comparing it to something else, and most people fall strongly on one side or the other.

A survey conducted by Kent Beck, and posted on his blog, [Three Rivers Institute](http://www.threeriversinstitute.org/blog/?p=541), shows that just around 25% of developers practice pair programming. And, this survey was done nearly 10 years after XP was published. Furthermore, Beck commented that he was pleased with these results. For whatever reason, pairing has been tough to implement.

In a [paper by Microsoft](http://research.microsoft.com/pubs/75108/esem-begel-2008.pdf) in 2008, their researchers took an in-depth look at whether pair programming would be beneficial at Microsoft. They conducted employee interviews, read industry studies, and compiled all the data. In the end, they concluded that pair programming would undoubtedly produce better quality software, but would lead to increased anxiety for the developers and take more time to produce working software. Again, there’s a mixed result.

I couldn’t find much evidence of other large companies who use paring, but [this post on Quora](http://www.quora.com/Which-companies-have-used-or-are-using-pair-programming) mentions that companies like Pivotal Labs, Xtreme Labs, Hashrocket, and Braintree pair by default, while Facebook, Square, Twitter, Goldstar, and Groupon do so occasionally. In a [Braintree blog post](https://www.braintreepayments.com/braintrust/code-quality-is-the-least-important-reason-to-pair-program), they mention many of the same values I discovered - quick ramp up, better company culture, and better knowledge transfer.

Perhaps pairing is a generational thing. The newer companies are embracing it and embedding it in their culture, while the seasoned veterans are merely dipping a toe in the water and can’t see what all the fuss is about. Many of the criticisms point towards increasing anxiety and putting developers in uncomfortable situations. Developers also say it takes longer, management doesn’t support it, or they prefer to work solo (probably because that’s what they’ve always done). Being so new, perhaps I don’t know any better.

Or, perhaps there’s not a binary, yes/no answer to the question, as [this blog post suggests](http://davenicolette.wordpress.com/2013/07/06/does-pair-programming-work/). Maybe it just depends on the situation and the team involved. Pairing will work really well for some problems and some teams, and not for others. I’m not certain which problems and which teams, but from what I’ve experienced thus far, I can tell that a good pairing session has the following traits:

- **Communication** - each person talks about what they are thinking. They explain their approach and discuss design ideas. When communication doesn’t happen, the pairing session can be frustrating or difficult.
- **Collaboration** - pairing should not be one sided. Each person gets a say in the final implementation, they have a chance to defend their perspective and suggest alternative approaches. Ultimately, this leads to better code and more robust solutions.
- **Patience** - if one person is struggling to understand, the other one helps them along. They do not force control of the keyboard or their approach to the problem. They take turns and are willing to teach.
- **Presence** - each person is focused and in the moment. They are not distracted by other problems or projects. It’s hard not to be productive when pairing.
- **Discipline** - the pair maintains discipline, even when faced with deadlines or frustrating problems. They stick to the basics and work through the problem logically.

If craftsmen maintain these traits, I can’t see many pairing sessions going poorly. I know I still have much to learn about the process of software craftsmanship, but at the moment, pairing has been beneficial to my journey. I hope to do much more of it in the future.
